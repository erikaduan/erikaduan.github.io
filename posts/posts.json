[
  {
    "path": "posts/2021-01-02-volcano-plots-with-ggplot2/",
    "title": "Volcano plots with ggplot2",
    "description": "Revising my grammar of graphics.",
    "author": [
      {
        "name": "Erika Duan",
        "url": {}
      }
    ],
    "date": "2021-01-02",
    "categories": [
      "data visualisation",
      "ggplot2",
      "R"
    ],
    "contents": "\r\n\r\nContents\r\nIntroduction\r\nImport a test dataset\r\nCreate a simple volcano plot\r\nAdd horizontal and vertical plot lines\r\nModify the x-axis and y-axis\r\nAdd colour, size and transparency\r\nLayer subplots\r\nLabel points of interest\r\nModify legend label positions\r\nModify plot labels and theme\r\nAnnotate text\r\nOther resources\r\n\r\nIntroduction\r\nIn 2018, whilst still an R newbie, I participated in the RLadies Melbourne community lightning talks and talked about how to visualise volcano plots in R. Volcano plots are probably an obscure concept outside of bioinformatics, but their construction nicely showcases the elegance of ggplot2.\r\nIn the last two years, a number of small and handy functions have been added to dplyr and ggplot2, which this post has been updated to reflect. 1\r\nLet’s get started then.\r\n\r\n\r\n#----load required packages----  \r\nif (!require(\"pacman\")) install.packages(\"pacman\")\r\npacman::p_load(here,  \r\n               tidyverse, \r\n               janitor, # for cleaning names  \r\n               scales, # for scale transformations  \r\n               ggrepel) # for optimal label separation  \r\n\r\n\r\n\r\nImport a test dataset\r\nWe start with a dataset with four columns:\r\nEntrez ID - stores the unique gene ID.\r\nGene symbol - stores the gene name associated with an unique Entrez ID.\r\nFold change - stores the change in gene expression level detected in diseased versus healthy tissue.\r\nAdjusted P-value - stores the P-value adjusted with a false discovery rate (FDR) correction for multiple testing.\r\nEvery row represents a unique gene expression fold change, which fulfills tidy data requirements for creating data visualisations.\r\nNote: The data used originates from Fu et al. Nat Cell Biol. 2015 and a copy of the original dataset can be found here.\r\n\r\n\r\n#----import and clean dataset---- \r\ndiseased_vs_healthy <- read.delim(here(\"data\", \"limma-voom_luminalpregnant-luminallactate.txt\"),\r\n                                  header = TRUE,\r\n                                  sep = \"\\t\")  \r\n\r\ndiseased_vs_healthy <- janitor::clean_names(diseased_vs_healthy)  \r\n\r\ndiseased_vs_healthy <- diseased_vs_healthy %>%\r\n  mutate(fold_change = 2^log_fc) %>%\r\n  select(entrezid,\r\n         symbol,\r\n         fold_change,\r\n         adj_p_val)  \r\n\r\n\r\n\r\n\r\nentrezid\r\nsymbol\r\nfold_change\r\nadj_p_val\r\n14367\r\nFzd5\r\n2.0716416\r\n0.0542520\r\n244144\r\nUsp35\r\n0.4197075\r\n0.0598292\r\n100216534\r\nSnord96a\r\n1.2373480\r\n0.9999999\r\n66151\r\nPrr13\r\n1.4296409\r\n0.9999999\r\n229445\r\nCtso\r\n1.0506197\r\n0.9999999\r\n\r\nCreate a simple volcano plot\r\nA basic version of a volcano plot depicts:\r\nAlong its x-axis: log2(fold_change)\r\nAlong its y-axis: -log10(adj_p_val)\r\nNote: The y-axis depicts -log10(adj_p_val), which allows the points on the plot to project upwards as the fold change greatly increases or decreases. This is more intuitive to visualise, as we are interested in the data points at the edges of the ‘volcano spray’.\r\nThe versatility of ggplot2 also means that you don’t need to store data transformations as separate variables for plotting. You can apply transformations directly inside ggplot(data, aes(x, y)) or alternatively by using scale_x_continuous(trans = \"...\") or coord_trans(x, y).\r\n\r\n\r\n#----create a simple volcano plot----\r\nvol_plot <- diseased_vs_healthy %>%\r\n  ggplot(aes(x = log2(fold_change),\r\n             y = -log10(adj_p_val))) + \r\n  geom_point() \r\n\r\nvol_plot # a simple volcano plot is created\r\n\r\n\r\n\r\n\r\nNote: For single layer plots, use %>% pipes with ggplot2 functions for convenience and readability.\r\nAdd horizontal and vertical plot lines\r\nThe functions geom_hline() and geom_vline() can be used to add extra horizontal and vertical lines on your plot respectively. In our example, I am interested in constructing boundaries for genes which have adj_p_val <= 0.05 and fold_change <= 0.5 or fold_change >= 2.\r\n\r\n\r\n#----plot extra quandrants----\r\nvol_plot + \r\n  geom_hline(yintercept = -log10(0.05),\r\n             linetype = \"dashed\") + \r\n  geom_vline(xintercept = c(log2(0.5), log2(2)),\r\n             linetype = \"dashed\")   \r\n\r\n\r\n\r\n\r\nModify the x-axis and y-axis\r\nVolcano plots should have a symmetrical x-axis. One way we can do this is by manually setting the limits of the x-axis using xlim(min, max).\r\n\r\n\r\n#----identify the best values for xlim----\r\ndiseased_vs_healthy %>%\r\n  pull(fold_change) %>%\r\n  min() %>%\r\n  log2() %>%\r\n  floor() \r\n#> [1] -10   \r\n\r\ndiseased_vs_healthy %>%\r\n  pull(fold_change) %>%\r\n  max() %>%\r\n  log2() %>%\r\n  ceiling()\r\n#> [1] 8  \r\n\r\nmax(abs(-10), abs(8))\r\n#> [1] 10  \r\n\r\n#----add xlim----  \r\nvol_plot + \r\n  geom_hline(yintercept = -log10(0.05),\r\n             linetype = \"dashed\") + \r\n  geom_vline(xintercept = c(log2(0.5), log2(2)),\r\n             linetype = \"dashed\") + \r\n  xlim(-10, 10) # manually specify x-axis limits \r\n\r\n\r\n\r\n\r\nWe can also change the limits of the x-axis inside scale_x_continuous. This method also gives us the flexibility to finetune the spacing and labelling of axis tick marks.\r\n\r\n\r\n#----modify scale_x_continuous----\r\nvol_plot + \r\n  geom_hline(yintercept = -log10(0.05),\r\n             linetype = \"dashed\") + \r\n  geom_vline(xintercept = c(log2(0.5), log2(2)),\r\n             linetype = \"dashed\") +\r\n  scale_x_continuous(breaks = c(seq(-10, 10, 2)), # modify x-axis tick intervals    \r\n                     limits = c(-10, 10)) \r\n\r\n\r\n\r\n\r\nNote: The value specified inside the argument scale_continuous_x(limits = ...) supercedes the range of values specified inside the argument scale_continuous_x(breaks = ...).\r\nAdd colour, size and transparency\r\nTo visualise different groups of genes using different colours, point sizes, shapes or transparencies, we need to categorise genes into different groups and store these categories as a new parameter i.e. new column of data.\r\nI am interested in labelling genes into the following groups:\r\nGenes with a fold change >= 2 and adjusted p-value <= 0.05 labelled as ‘up’.\r\nGenes with a fold change <= 0.5 and adjusted p-value <= 0.05 labelled as ‘down’.\r\nAll other genes labelled as ‘ns’ i.e. non-significant.\r\n\r\n\r\n#----create a new column which distinguishes individual rows by type---- \r\ndiseased_vs_healthy <- diseased_vs_healthy %>%\r\n  mutate(gene_type = case_when(fold_change >= 2 & adj_p_val <= 0.05 ~ \"up\",\r\n                               fold_change <= 0.5 & adj_p_val <= 0.05 ~ \"down\",\r\n                               TRUE ~ \"ns\"))   \r\n\r\n#----obtain a summary of gene_type numbers----           \r\ndiseased_vs_healthy %>%\r\n  count(gene_type)\r\n\r\n# the function count() is equivalent to     \r\n\r\n# diseased_vs_healthy %>%\r\n#   group_by(gene_type) %>%\r\n#   summarize(count = n()) \r\n\r\n\r\n\r\n\r\ngene_type\r\nn\r\ndown\r\n1245\r\nns\r\n13578\r\nup\r\n981\r\n\r\nIn ggplot2, we have the option to visualise different groups by point colour, size, shape and transparency by modifying parameter like scale_color_manual() etc. A tidy way of doing this is to store manual specifications as vectors.\r\n\r\n\r\n#----double check gene_type categories----    \r\ndiseased_vs_healthy %>%\r\n  distinct(gene_type) %>%\r\n  pull()  \r\n#> [1] \"down\" \"up\"   \"ns\"    \r\n\r\n\r\n\r\n\r\n\r\n#----add colour, size and alpha (transparency) specs to volcano plot---- \r\ncols <- c(\"up\" = \"#ffad73\", \"down\" = \"#26b3ff\", \"ns\" = \"grey\") \r\nsizes <- c(\"up\" = 2, \"down\" = 2, \"ns\" = 1) \r\nalphas <- c(\"up\" = 1, \"down\" = 1, \"ns\" = 0.5)\r\n\r\ndiseased_vs_healthy %>%\r\n  ggplot(aes(x = log2(fold_change),\r\n             y = -log10(adj_p_val),\r\n             fill = gene_type,    \r\n             size = gene_type,\r\n             alpha = gene_type)) + \r\n  geom_point(shape = 21, # specify shape and colour as fixed local parameters    \r\n             colour = \"black\") + \r\n  geom_hline(yintercept = -log10(0.05),\r\n             linetype = \"dashed\") + \r\n  geom_vline(xintercept = c(log2(0.5), log2(2)),\r\n             linetype = \"dashed\") +\r\n  scale_fill_manual(values = cols) + # modify colour\r\n  scale_size_manual(values = sizes) + # modify point size\r\n  scale_alpha_manual(values = alphas) + # modify point transparency\r\n  scale_x_continuous(breaks = c(seq(-10, 10, 2)), # modify x-axis tick intervals    \r\n                     limits = c(-10, 10))  \r\n\r\n\r\n\r\n\r\nLayer subplots\r\nWe can also overlay subplots on top of our main plot. This is useful when we want to highlight a subset of our data using different colours, shapes and etc. When overlaying plots, we should not use %>% pipes but use global ggplot(data = “…”) and local geom_point(data = ...) arguments instead.\r\n\r\n\r\n#----add a subplot to the main volcano plot----  \r\nils <- str_subset(diseased_vs_healthy$symbol, \"^[I|i]l[0-9]+$\")  \r\n\r\nil_genes <- diseased_vs_healthy %>%\r\n  filter(symbol %in% ils) \r\n\r\nggplot(data = diseased_vs_healthy, # original data  \r\n       aes(x = log2(fold_change), y = -log10(adj_p_val))) + \r\n  geom_point(colour = \"grey\", alpha = 0.5) +\r\n  geom_point(data = il_genes, # data subset    \r\n             size = 2,\r\n             shape = 21,\r\n             fill = \"firebrick\",\r\n             colour = \"black\")     \r\n\r\n\r\n\r\n\r\nNote: Unless local aesthetics are specified, secondary geom_point() functions will still inherit glocal ggplot aesthetics.\r\nLabel points of interest\r\nWe can also label a subset of data using geom_text(), geom_label(), geom_text_repel() or geom_label_repel and by specifying which column to display as text using the local argument geom_text(aes(label = ...)).\r\nNote: adjusting the parameters for optimal text separation using geom_text_repel can be a bit fiddly. I generally start by modifying force and then deciding which region of the plot I want to nudge my text or labels towards. See here for more tips on adjusting geom_text_repel parameters.\r\n\r\n\r\n#-----create subplots of interest---- \r\nsig_il_genes <- diseased_vs_healthy %>%\r\n  filter(symbol %in% c(\"Il15\", \"Il34\", \"Il24\"))\r\n\r\nup_il_genes <- diseased_vs_healthy %>%\r\n  filter(symbol == \"Il24\")\r\n\r\ndown_il_genes <- diseased_vs_healthy %>%\r\n  filter(symbol %in% c(\"Il15\", \"Il34\"))\r\n\r\n#----visual layered and labelled volcano plot---- \r\nggplot(data = diseased_vs_healthy,\r\n       aes(x = log2(fold_change),\r\n           y = -log10(adj_p_val))) + \r\n  geom_point(aes(colour = gene_type), \r\n             alpha = 0.2, \r\n             shape = 16,\r\n             size = 1) + \r\n  geom_point(data = up_il_genes,\r\n             shape = 21,\r\n             size = 2, \r\n             fill = \"firebrick\", \r\n             colour = \"black\") + \r\n  geom_point(data = down_il_genes,\r\n             shape = 21,\r\n             size = 2, \r\n             fill = \"steelblue\", \r\n             colour = \"black\") + \r\n  geom_hline(yintercept = -log10(0.05),\r\n             linetype = \"dashed\") + \r\n  geom_vline(xintercept = c(log2(0.5), log2(2)),\r\n             linetype = \"dashed\") +\r\n  geom_label_repel(data = sig_il_genes, # add labels last as the top layer to plot   \r\n                   aes(label = symbol),\r\n                   force = 2,\r\n                   nudge_y = 1) +\r\n  scale_colour_manual(values = cols) + \r\n  scale_x_continuous(breaks = c(seq(-10, 10, 2)),     \r\n                     limits = c(-10, 10))  \r\n\r\n\r\n\r\n\r\nModify legend label positions\r\nIf we want to change the order of discrete figure legend labels, you need to modify the factor levels of your dataset grouping. This can be done using the forcats package, which allows us to easily modify factor levels.\r\n\r\n\r\n#----modify factor gene_type levels----  \r\ndiseased_vs_healthy <- diseased_vs_healthy %>%\r\n  mutate(gene_type = fct_relevel(gene_type, \"up\", \"down\")) \r\n\r\n# apply fct_relevel so the first two levels are \"up\" and \"down\"  \r\n\r\n#----recreate volcano plot----  \r\nggplot(data = diseased_vs_healthy,\r\n       aes(x = log2(fold_change),\r\n           y = -log10(adj_p_val))) + \r\n  geom_point(aes(colour = gene_type), \r\n             alpha = 0.2, \r\n             shape = 16,\r\n             size = 1) + \r\n  geom_point(data = up_il_genes,\r\n             shape = 21,\r\n             size = 2, \r\n             fill = \"firebrick\", \r\n             colour = \"black\") + \r\n  geom_point(data = down_il_genes,\r\n             shape = 21,\r\n             size = 2, \r\n             fill = \"steelblue\", \r\n             colour = \"black\") + \r\n  geom_hline(yintercept = -log10(0.05),\r\n             linetype = \"dashed\") + \r\n  geom_vline(xintercept = c(log2(0.5), log2(2)),\r\n             linetype = \"dashed\") +\r\n  geom_label_repel(data = sig_il_genes, # add labels last as the top layer to plot   \r\n                   aes(label = symbol),\r\n                   force = 2,\r\n                   nudge_y = 1) +\r\n  scale_colour_manual(values = cols) + \r\n  scale_x_continuous(breaks = c(seq(-10, 10, 2)),     \r\n                     limits = c(-10, 10))   \r\n\r\n\r\n\r\n\r\nNote: If we wanted to change the text displayed in the figure legend, we would need to modify the factor levels (i.e. variable categories) themselves.\r\nModify plot labels and theme\r\nThe last finishing touches include modifying plot labels and plot theme.\r\nThe function labs() is a handy way of specifying all your plot labels within a single function. You can also assign labels as NULL to prevent them from being displayed.\r\nA plot can be further improved by changing its theme() and/or by modifying individual theme() parameters.\r\n\r\n\r\n#----add plot labels and modify plot theme----\r\nfinal_plot <- ggplot(data = diseased_vs_healthy,\r\n       aes(x = log2(fold_change),\r\n           y = -log10(adj_p_val))) + \r\n  geom_point(aes(colour = gene_type), \r\n             alpha = 0.2, \r\n             shape = 16,\r\n             size = 1) + \r\n  geom_point(data = up_il_genes,\r\n             shape = 21,\r\n             size = 2, \r\n             fill = \"firebrick\", \r\n             colour = \"black\") + \r\n  geom_point(data = down_il_genes,\r\n             shape = 21,\r\n             size = 2, \r\n             fill = \"steelblue\", \r\n             colour = \"black\") + \r\n  geom_hline(yintercept = -log10(0.05),\r\n             linetype = \"dashed\") + \r\n  geom_vline(xintercept = c(log2(0.5), log2(2)),\r\n             linetype = \"dashed\") +\r\n  geom_label_repel(data = sig_il_genes, # add labels last as the top layer to plot   \r\n                   aes(label = symbol),\r\n                   force = 2,\r\n                   nudge_y = 1) +\r\n  scale_colour_manual(values = cols) + \r\n  scale_x_continuous(breaks = c(seq(-10, 10, 2)),     \r\n                     limits = c(-10, 10)) +\r\n  labs(title = \"Gene expression changes in diseased versus healthy samples\",\r\n       x = \"log2(fold change)\",\r\n       y = \"-log10(adjusted P-value)\",\r\n       colour = \"Expression \\nchange\") +\r\n  theme_bw() + # creates a white background\r\n  theme(panel.border = element_rect(colour = \"black\", fill = NA, size= 0.5), # creates a plot border \r\n        panel.grid.minor = element_blank(),\r\n        panel.grid.major = element_blank()) \r\n\r\nfinal_plot \r\n\r\n\r\n\r\n\r\nNote: You can specify panel.grid... = element_line(linetype = \"dotted\") inside theme() to create dotted gridlines along the x and/or y axis. Major gridline positions are inherited from the values of axis breaks.\r\nAnnotate text\r\nWe can add descriptive labels to our plot by using the function annotate() to display text.\r\n\r\n\r\n#----annotate text inside plot----\r\nfinal_plot + \r\n  annotate(\"text\", x = 7, y = 10,\r\n           label = \"3 interleukins of interest\", color = \"firebrick\")\r\n\r\n\r\n\r\n\r\nOther resources\r\nThe excellent and interactive code-along RStudio Cloud ggplot2 tutorials\r\nRStudio ggplot cheatsheet\r\nSTHDA tutorial on ggplot2 axis transformations\r\n\r\nThe original coding logic should still be attributed to Chuanxin Liu, my former PhD student. I also recommend the excellent RStudio Cloud ggplot2 tutorials, which have taught me a few new tricks.↩\r\n",
    "preview": "posts/2021-01-02-volcano-plots-with-ggplot2/finalplot.png",
    "last_modified": "2021-01-05T14:09:54+11:00",
    "input_file": {},
    "preview_width": 2187,
    "preview_height": 1350
  },
  {
    "path": "posts/2020-12-31-cleaning-free-text-and-wrangling-strings/",
    "title": "Cleaning free text and wrangling strings",
    "description": "These are some common data cleaning things.",
    "author": [
      {
        "name": "Erika Duan",
        "url": {}
      }
    ],
    "date": "2020-12-31",
    "categories": [
      "data cleaning",
      "regex",
      "R"
    ],
    "contents": "\r\n\r\nContents\r\nIntroduction\r\nCreate a test dataset\r\nIntroduction to regular expressionsMatch characters\r\nCharacter anchors\r\nCharacter classes and groupings\r\nGreedy versus lazy matches\r\nLook arounds\r\n\r\nImprove comment field readability\r\nManually extract topics of interest\r\nExtract a machine learning friendly dataset\r\nDifferences between base R and stringr functions\r\nOther resources\r\n\r\nIntroduction\r\nComment fields sit somewhere in between tidy tabular data entries and large text files (i.e. documents) in terms of wrangling effort. They require human naunce to decode and the quality and completeness of comments vary between individual entries.\r\nThis makes it hard to gauge whether cleaning comment fields is a worthwhile endeavour (especially when you have multiple other data sources that need examining). Luckily, some knowledge of string manipulations and regular expressions can help simplify this process.\r\nLet’s get started.\r\n\r\n\r\n#-----load required packages-----  \r\nif (!require(\"pacman\")) install.packages(\"pacman\")\r\npacman::p_load(here,  \r\n               tidyverse,  \r\n               microbenchmark) \r\n\r\n\r\n\r\nCreate a test dataset\r\nLet’s imagine that my local chocolate company, Haighs Chocolates, wants to understand what food critics versus Haighs fans think about their newest product. They send out a bag of free samples with a link to an online survey that asks individuals to rate their chocolates (on a scale of 1 to 10) and provide additional comments.\r\nNote: The code used to create this survey can be accessed from my github repository here.\r\n\r\n\r\n\r\n\r\n\r\n#-----examine the first few rows of data-----  \r\nsurvey %>%\r\n  head(6) # fields containing html flags are not properly rendered by kable \r\n\r\n\r\n# A tibble: 6 x 3\r\n  respondee rating comment_field                                      \r\n  <chr>     <chr>  <chr>                                              \r\n1 expert_1  8      \"<textarea name=\\\"comment\\\" form=\\\"1\\\"> &lt;Grade ~\r\n2 expert_2  7      \"<textarea name=\\\"comment\\\" form=\\\"1\\\"> &lt;Grade ~\r\n3 expert_3  8      \"<textarea name=\\\"comment\\\" form=\\\"1\\\"> &lt;Grade ~\r\n4 expert_4  10     \"<textarea name=\\\"comment\\\" form=\\\"1\\\"> &lt;Grade ~\r\n5 expert_5  7      \"<textarea name=\\\"comment\\\" form=\\\"1\\\"> &lt;Grade ~\r\n6 fan_1     9      \"<textarea name=\\\"comment\\\" form=\\\"1\\\"> Delicious ~\r\n\r\nOh dear, it looks like we will first need to use regular expressions to remove all the html tags embedded within survey$comment_field.\r\nIntroduction to regular expressions\r\nRegular expressions, or regex, can be thought of as a separate syntax for handling patterns in strings. In R, regular expressions can be directly enclosed inside quotes like character strings or explicitly referenced inside regex(). For convenience, I prefer the former approach but the latter approach can help increase code readability.\r\n\r\n\r\n#-----call regular expressions in R-----\r\nmany_apples <- c(\"Apple\", \"apple\", \"APPLE\", \"apples\")\r\n\r\nstr_extract(many_apples, \r\n            \"apples?\")  \r\n#> [1] NA       \"apple\"  NA       \"apples\"\r\n\r\n#-----call regular expressions in R using regex()-----\r\n# regex() provides additional arguments\r\n\r\nstr_extract(many_apples, \r\n            regex(\"apples?\", ignore_case = T))  \r\n#> [1] \"Apple\"  \"apple\"  \"APPLE\"  \"apples\"\r\n\r\n# regex() also allows comments to improve regex readability  \r\n\r\nstr_extract(many_apples, \r\n            regex(\"\r\n                  apple  # contains the word apple\r\n                  s?  # contains zero or one of the letter s\r\n                  \" , comments = T))\r\n#> [1] NA       \"apple\"  NA       \"apples\"  \r\n\r\n\r\n\r\nMatch characters\r\nSome sequences of characters have specific meanings. For example, s refers to the letter \"s\" but \\s refers to any type of white space. To call whitespace in R, a second backslash \\ is required to escape special character behaviour i.e. \\\\s.\r\n\r\n\r\n#-----examples of special character sequences-----  \r\nwords_and_spaces <- c(\" a cat\",\r\n                      \"acat\",\r\n                      \"a   cat\",\r\n                      \"a\\ncat\",\r\n                      \"a\\\\ncat\")\r\n\r\n# \"a\\\\s+cat\" calls variations of a...cat separated by one or more whitespaces \r\n# note that the string \"a\\ncat\" also counts because \\n refers to a new line\r\n\r\nstr_extract(words_and_spaces, \"a\\\\s+cat\")  \r\n#> [1] \"a cat\"   NA        \"a   cat\" \"a\\ncat\"  NA      \r\n\r\n# \"\\\\S+\" refers to everything that is not white space (starting from left to right)  \r\n\r\nstr_extract(words_and_spaces, \"\\\\S+\")  \r\n#> [1] \"a\"       \"acat\"    \"a\"       \"a\"       \"a\\\\ncat\"\r\n\r\n\r\n\r\nNote: The special characters \\s versus \\S allow the extraction of opposite pattern types. In another example, lowercase \\w refers to any word character whilst uppercase \\W and lowercase [^\\w] both refer to anything that is not a word character.\r\nCharacter anchors\r\nI feel that the goal of writing good regex is to be as specific as possible. This is why character anchors are useful (i.e. using ^ and $ to denote the start and end of your string respectively).\r\nIf we revisit the example above, we can see that the presence or absence of character anchors produces very different outputs.\r\n\r\n\r\n#-----impact of character anchors-----    \r\nwords_and_spaces <- c(\" a cat\",\r\n                      \"acat\",\r\n                      \"a   cat\",\r\n                      \"a\\ncat\",\r\n                      \"a\\\\ncat\")\r\n\r\n# \"\\\\S+\" refers to everything that is not white space (from left to right unless specified)  \r\n\r\nstr_extract(words_and_spaces, \"\\\\S+\")  \r\n#> [1] \"a\"       \"acat\"    \"a\"       \"a\"       \"a\\\\ncat\"  \r\n\r\nstr_extract(words_and_spaces, \"^\\\\S+\")  \r\n#> [1] NA       \"acat\"    \"a\"       \"a\"       \"a\\\\ncat\"   \r\n\r\nstr_extract(words_and_spaces, \"\\\\S+$\") \r\n#> [1] \"cat\"     \"acat\"    \"cat\"     \"cat\"     \"a\\\\ncat\"       \r\n\r\n\r\n\r\nCharacter classes and groupings\r\nCharacter classes and groupings are handy for extracting specific letter and/or digit combinations. Some special characters found inside character classes and groupings are:\r\nThe operation or is represented by | i.e [a|c]\r\nThe operation range is represented by - i.e. [a-z]\r\nThe operation excludes is represented by ^ i.e. [^a-c]\r\nNote: Representation of a single character is denoted by [] and representation of a grouping i.e. combination of characters is denoted by ().\r\n\r\n\r\n#-----extract patterns using character classes i.e. []-----    \r\nstrange_fruits <- c(\"apple1\",\r\n                    \"bapple2\",\r\n                    \"capple3\",\r\n                    \"dapple4\",\r\n                    \"epple5\",\r\n                    \"aggle0\")\r\n\r\nstr_extract(strange_fruits, \"[a-d]\")\r\n#> [1] \"a\" \"b\" \"c\" \"d\" NA  \"a\"  \r\n\r\nstr_extract(strange_fruits, \"[a-d][^p]\")\r\n#> [1] NA   \"ba\" \"ca\" \"da\" NA   \"ag\"   \r\n\r\n# [a-d][^p] refers to one character between a and d followed by one character that is not p  \r\n\r\nstr_extract(strange_fruits, \"[0|4-9]\")\r\n#> [1] NA  NA  NA  \"4\" \"5\" \"0\"   \r\n\r\n# [0|4-9] refers to one number that is zero or a number from 4 to 9    \r\n\r\n\r\n\r\n\r\n\r\n#-----extract character using groupings i.e. ()-----     \r\nstrange_fruits <- c(\"apple1\",\r\n                    \"bapple2\",\r\n                    \"capple3\",\r\n                    \"dapple4\",\r\n                    \"epple5\",\r\n                    \"aggle1\")  \r\n\r\nstr_extract(strange_fruits, \"a(pp|gg)le\")\r\n#> [1] \"apple\" \"apple\" \"apple\" \"apple\" NA      \"aggle\"    \r\n\r\n# groups can be referenced by their order of appearance i.e. \\\\1 = first group  \r\n\r\nstr_extract(strange_fruits, \"(a)(p|g)\\\\2\")\r\n#> [1] \"app\" \"app\" \"app\" \"app\" NA    \"agg\"   \r\n\r\n# (a) is group 1 and can be called using \\\\1    \r\n# (p|g) is group 2 and can be called using \\\\2     \r\n\r\n\r\n\r\nGreedy versus lazy matches\r\nIn R, regular expression parsing is non-greedy by default. This means that we need to add quantifiers * and + to greedily extract zero or more and one or more characters respectively.\r\nIn contrast, using a non-greedy match allows you to extract just the first characters before a white space or punctuation mark. This is useful for trimming strings or extracting file or object names.\r\n\r\n\r\n\r\n\r\n\r\n#-----use cases for greedy matches-----   \r\nmessy_dates <- c(\"Thursday 24th May\",\r\n                 \"Thursday  24th May  \",\r\n                 \" May\",\r\n                 \"May    \")\r\n\r\nstr_extract(messy_dates, \"^\\\\w\")      \r\n#> [1] \"T\" \"T\" NA  \"M\"   \r\n\r\n# greedily extract the first word in the string    \r\n\r\nstr_extract(messy_dates, \"^\\\\w+\")   \r\n#> [1] \"Thursday\" \"Thursday\" NA      \"May\"   \r\n\r\nstr_extract(messy_dates, \"^\\\\w{1,}\") # the quantifier + and {1,} are equivalent    \r\n#> [1] \"Thursday\" \"Thursday\" NA      \"May\"    \r\n\r\nstr_extract(messy_dates, \"^(\\\\S+)\")  \r\n#> [1] \"Thursday\" \"Thursday\" NA      \"May\"    \r\n\r\n#-----use cases for non-greedy matches----- \r\nstr_replace_all(messy_dates, \"\\\\s\" , \"-\") # replaces each individual whitespace\r\n#> [1] \"Thursday-24th-May\"    \"Thursday--24th-May--\" \"-May\"                  \"May----\"       \r\n\r\nstr_replace_all(messy_dates, \"\\\\s{1,2}\" , \"-\") \r\n#> [1] \"Thursday-24th-May\"  \"Thursday-24th-May-\" \"-May\"                \"May--\"         \r\n\r\n# use look arounds (next topic) to replace the whitespace(s) after the first word     \r\n\r\nstr_replace_all(messy_dates, \"(?<=^\\\\w{1,100})\\\\s{1,2}\" , \"-\") \r\n#> [1] \"Thursday-24th May\"   \"Thursday-24th May  \" \" May\"                 \"May-  \"     \r\n\r\n\r\n\r\nNote: For further details explaining the regex syntax for the last example, read this stack overflow post.\r\nLook arounds\r\nLook around operations are useful when you are unsure of the pattern itself, but you know exactly what its preceding or following pattern is. I’ve found that the clearest explanation of look around operations comes from the RStudio cheetsheet on string_r, as depicted below.\r\n\r\n\r\n\r\nFigure 1: Taken from the RStudio stringr cheatsheet\r\n\r\n\r\n\r\n\r\n\r\n#-----use cases for different types of look arounds-----  \r\nrecipes <- c(\"crossiant recipes\",\r\n             \"apple pie recipe\",\r\n             \"chocolate cake  recipe\", # extra space\r\n             \"cookie receipe\",  # deliberate typo\r\n             \"secret KFC-recipe\", \r\n             \"very secret  McDonalds soft-serve recipe\") # extra space  \r\n\r\n# use positive look-ahead (?=...) to extract the preceding word\r\n\r\nstr_extract(recipes, \"\\\\S+(?=\\\\s*recipes?)\")   \r\n#> [1] \"crossiant\"  \"pie\"        \"cake\"       NA           \"KFC-\"       \"soft-serve\"   \r\n\r\n# use positive look-behind (?<=) on \"secret\" to identify the secret recipes  \r\n\r\nstr_extract(recipes, \"(?<=secret\\\\s{1,10})\\\\S+.+\")   \r\n#> [1] NA                            NA                            NA                           \r\n#> [4] NA                            \"KFC-recipe\"                  \"McDonalds soft-serve recipe\"   \r\n\r\n\r\n\r\nNote: Positive look-behinds require defined boundary specifications i.e. the operation + needs to be converted into {1,1000}.\r\nImprove comment field readability\r\nWith regex revised, let us return to our Haighs chocolate survey. The first thing we can see is that html tags have been retained inside the comment field and that this field is very long (i.e. difficult to read).\r\nWe can improve the readability of the survey by:\r\nRemoving all html tags using regex.\r\nSeparating phrases into columns using separate().\r\n\r\n\r\n#-----re-examine survey data-----\r\nsurvey %>%\r\n  head(5)   \r\n\r\n\r\n# A tibble: 5 x 3\r\n  respondee rating comment_field                                      \r\n  <chr>     <chr>  <chr>                                              \r\n1 expert_1  8      \"<textarea name=\\\"comment\\\" form=\\\"1\\\"> &lt;Grade ~\r\n2 expert_2  7      \"<textarea name=\\\"comment\\\" form=\\\"1\\\"> &lt;Grade ~\r\n3 expert_3  8      \"<textarea name=\\\"comment\\\" form=\\\"1\\\"> &lt;Grade ~\r\n4 expert_4  10     \"<textarea name=\\\"comment\\\" form=\\\"1\\\"> &lt;Grade ~\r\n5 expert_5  7      \"<textarea name=\\\"comment\\\" form=\\\"1\\\"> &lt;Grade ~\r\n\r\n#-----remove html tags-----\r\nremove_html_tags <- regex(\"\r\n                          <  # starts with <\r\n                          [^>]+  # contains one or more of all characters excepting > \r\n                          >  # ends with >\r\n                          \", comments = T)\r\n\r\nremove_more_html <- regex(\"\r\n                          \\\\& # starts with &\r\n                          \\\\w+ # contains one or more word characters\r\n                          \\\\; # ends with ;\r\n                          \", comments = T) \r\n\r\nsurvey <- survey %>%\r\n  mutate(comment_field = str_replace_all(comment_field, remove_html_tags, \"\"),\r\n         comment_field = str_replace_all(comment_field, remove_more_html, \"\"))\r\n\r\n#-----examine comment field-----  \r\nsurvey %>%\r\n  select(comment_field) %>%\r\n  head(5) \r\n\r\n\r\n# A tibble: 5 x 1\r\n  comment_field                                                       \r\n  <chr>                                                               \r\n1 \" Grade A beans. Easily melts. Smooth chocolate shell, with a crunc~\r\n2 \" Grade A beans with subtle caramel hints. Melts well. Smooth exter~\r\n3 \" Grade a beans.  Caramel and vanilla undertones complement the bit~\r\n4 \" Grade A cocoa beans. Melts easily. Smooth dark chocolate contrast~\r\n5 \" Grade A beans, likely of Ecuador origin. Smooth dark chocolate co~\r\n\r\nWe can then split the single long comment field into multiple smaller columns. 1\r\n\r\n\r\n#-----separate comment field into an unknown number of columns-----    \r\nnmax <- max(str_count(survey$comment_field, \"[[:punct:]]|and|with|against\")) + 1\r\n\r\nsurvey <- survey %>%   \r\n  separate(comment_field,\r\n           into = paste0(\"Field\", seq_len(nmax)),\r\n           sep = \"[[:punct:]]|and|with|against\", # separate on punctuation or conjunctions  \r\n           remove = F,\r\n           extra = \"warn\",\r\n           fill = \"right\") \r\n\r\n#-----examine comment fields-----  \r\nsurvey %>%\r\n  select(starts_with(\"Field\")) %>%\r\n  head(5) \r\n\r\n\r\n\r\nManually extract topics of interest\r\nAfter separating the comment field into smaller fields, we see references to:\r\ncocoa bean grade\r\npresence of caramel or vanilla flavour\r\nchocolate smoothness\r\nhow well the chocolate melts\r\nsugar content/ sweetness level\r\nmalt filling\r\nchocolate coating\r\nInformation about cocoa bean grade is highly structured. This means that extracting the letter following the word “Grade” is sufficient. A similar logic can be applied to extract whether caramel or vanilla flavour or chocolate smoothness was mentioned.\r\n\r\n\r\n#----extract information about cocoa bean grade, flavour and smoothness----\r\ntidy_survey <- survey %>%\r\n  select(respondee,\r\n         comment_field) %>% \r\n  mutate(cocoa_grade = str_extract(comment_field, \"(?<=[G|g]rade\\\\s{0,10})[A-C|a-c]\"),\r\n         is_caramel = case_when(str_detect(comment_field, \"[C|c]aramel\") ~ \"yes\",\r\n                                TRUE ~ \"NA\"), \r\n         is_vanilla = case_when(str_detect(comment_field, \"[V|v]anilla\") ~ \"yes\",\r\n                                TRUE ~ \"NA\"),\r\n         is_smooth = case_when(str_detect(comment_field, \"[S|s]mooth\") ~ \"yes\",\r\n                               TRUE ~ \"NA\")) \r\n\r\n# we cannot assign TRUE ~ NA inside case_when  \r\n\r\ntidy_survey <- tidy_survey %>%\r\n  mutate_at(vars(cocoa_grade), ~ replace_na(., \"NA\"))\r\n\r\n# replace NA in cocoa_grade with the character \"NA\" for consistency  \r\n\r\n\r\n\r\nFor more descriptive fields such as whether the chocolate melts, I find it easier to first extract a matrix of fields.\r\n\r\n\r\n#----extract information about chocolate texture----\r\nmelt_matrix <- survey %>%\r\n  select_at(vars(respondee,\r\n                 starts_with(\"Field\"))) %>% \r\n  mutate_at(vars(starts_with(\"Field\")),\r\n            ~ replace(.x, !(str_detect(.x, \".*\\\\b[M|m]elt.*\\\\b.*\")), NA)) \r\n\r\n# convert fields which do not contain \"melt\" into NA and unite all fields     \r\n\r\nmelt_cols <- str_which(colnames(melt_matrix), \"^Field.+\")\r\n\r\nmelt_status <- melt_matrix %>%\r\n  unite(\"is_melty\", # new column \r\n        all_of(melt_cols), # unite these columns  \r\n        sep = \"\",\r\n        remove = T,\r\n        na.rm = T) # make sure to remove NAs  \r\n\r\n#----convert responses into factors and recode factor levels----  \r\nmelt_status$is_melty <- factor(melt_status$is_melty)\r\n\r\nlevels(melt_status$is_melty) \r\n#> [1] \"\"                     \" Easily melts\"        \" Melts easily\"        \" melts in your mouth\" \" Melts well\"         \r\n\r\nmelt_status <- melt_status %>%\r\n  mutate(is_melty = fct_collapse(is_melty,\r\n                                 \"yes\" = c(\" Easily melts\",\r\n                                           \" Melts well\",\r\n                                           \" Melts easily\",\r\n                                           \" melts in your mouth\"),\r\n                                 \"NA\" = \"\"))\r\n\r\n#----left join tidy_survey to melt_status----  \r\ntidy_survey <- tidy_survey %>%\r\n  left_join(melt_status,\r\n            by = \"respondee\")\r\n\r\n\r\n\r\nThis process is repeated for chocolate sweetness. 2\r\n\r\n\r\n#----extract information about chocolate sweetness----  \r\nsweetness_matrix <- survey %>%\r\n  select_at(vars(respondee,\r\n                 starts_with(\"Field\"))) %>% \r\n  mutate_at(vars(starts_with(\"Field\")),\r\n            ~ replace(.x, !(str_detect(.x, \".*\\\\b[S|s](weet)|(ugar).*\\\\b.*\")), NA)) \r\n\r\n# convert fields which do not contain \"sweet\" or \"sugar\" into NA and unite all fields     \r\n\r\nsweetness_cols <- str_which(colnames(sweetness_matrix), \"^Field.+\")\r\n\r\nsweetness_status <- sweetness_matrix %>%\r\n  unite(\"is_sweet\", \r\n        all_of(sweetness_cols), \r\n        sep = \"\",\r\n        remove = T,\r\n        na.rm = T) # make sure to remove NAs  \r\n\r\n#----convert responses into factors and recode factor levels---- \r\nsweetness_status$is_sweet <- factor(sweetness_status$is_sweet)\r\n\r\nlevels(sweetness_status$is_sweet)\r\n#> [1] \"\"                                      \" low sugar content \"                   \" not so sweet  I enjoyed this\"        \r\n#> [4] \"filled core may be too sweet for some\"\r\n\r\nsweetness_status <- sweetness_status %>%\r\n  mutate(is_sweet = fct_collapse(is_sweet,\r\n                                 \"yes\" = c(\"filled core may be too sweet for some\"),\r\n                                 \"no\" = c(\" low sugar content \",\r\n                                          \" not so sweet  I enjoyed this\"),\r\n                                 \"NA\" = \"\"))\r\n\r\n#----left join tidy_survey to melt_status----  \r\ntidy_survey <- tidy_survey %>%\r\n  left_join(sweetness_status,\r\n            by = \"respondee\")\r\n\r\n\r\n\r\nNote: This method of converting topics into tabular variables works well when we are not dealing with too many factors (i.e. when recoding factors is not too cumbersome).\r\nExtract a machine learning friendly dataset\r\nA reason why we might be interested in converting unstructured comment fields into structured variables is to generate data features for machine learning. For instance, we might be interested in whether there is a relationship between survey topics, whether the comment comes from a critic or chocolate fan, and the chocolate rating.\r\n\r\n\r\n#----create final tidy_survey----\r\nsurvey_rating <- survey %>%\r\n  select(respondee,\r\n         rating) # extract rating  \r\n\r\ntidy_survey <- tidy_survey %>%\r\n  select(-comment_field) %>%\r\n  left_join(survey_rating,\r\n            by = \"respondee\") %>%\r\n  mutate(respondee = str_extract(respondee, \".+(?=\\\\_[0-9]+)\"))\r\n\r\nset.seed(123) # sample reproducibly  \r\ntidy_survey %>%\r\n  sample_n(5)   \r\n\r\n\r\n\r\nDifferences between base R and stringr functions\r\nIn R, string manipulation can be performed using either base R functions or functions from the stringr library. A key difference between base R and stringr functions is the order that the string and pattern are specified. The pattern, not the string, is specified first inside base R functions, which is not a pipe friendly argument order.\r\n\r\n\r\n#-----use cases for grep()-----  \r\ndesserts <- c(\"chocolate\",\r\n              \"chocolate cake\",\r\n              \"chocolate tart\",\r\n              \"chocolate icecream\",\r\n              \"chocolate cookies\",\r\n              \"dark chocolate fudge\", \r\n              \"fruit\",\r\n              \"fruit tart\",\r\n              \"fruit sorbet\")\r\n\r\ngrep(\".*\\\\bchocolate\\\\b.*\", desserts, value = F) # default is value = FALSE\r\n#> [1] 1 2 3 4 5 6  \r\n\r\n# grep, value = FALSE only extracts the position of matching elements in the vector  \r\n\r\nstr_which(desserts, \".*\\\\bchocolate\\\\b.*\")  \r\n#> [1] 1 2 3 4 5 6  \r\n\r\ngrep(\".*\\\\bchocolate\\\\b.*\", desserts, value = T) \r\n#> [1] \"chocolate\"            \"chocolate cake\"       \"chocolate tart\"       \"chocolate icecream\"  \r\n#> [5] \"chocolate cookies\"    \"dark chocolate fudge\"   \r\n\r\n# grep, value = TRUE extracts the matching elements in the vector  \r\n\r\nstr_subset(desserts, \".*\\\\bchocolate\\\\b.*\") \r\n#> [1] \"chocolate\"            \"chocolate cake\"       \"chocolate tart\"       \"chocolate icecream\"  \r\n#> [5] \"chocolate cookies\"    \"dark chocolate fudge\"  \r\n\r\n# str_subset() is a wrapper around x[str_detect(x, pattern)]   \r\n\r\n\r\n\r\n\r\n\r\n#-----use cases for grepl()-----  \r\ndesserts <- c(\"chocolate\",\r\n              \"chocolate cake\",\r\n              \"chocolate tart\",\r\n              \"chocolate icecream\",\r\n              \"chocolate cookies\",\r\n              \"dark chocolate fudge\", \r\n              \"fruit\",\r\n              \"fruit tart\",\r\n              \"fruit sorbet\")\r\n\r\ngrepl(\".*\\\\bchocolate\\\\b.*\", desserts) \r\n#> [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE  \r\n\r\nstr_detect(desserts, \".*\\\\bchocolate\\\\b.*\")  \r\n#> [1]  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE \r\n\r\ndesserts[str_detect(desserts, \".*\\\\bchocolate\\\\b.*\")]\r\n#> [1] \"chocolate\"            \"chocolate cake\"       \"chocolate tart\"       \"chocolate icecream\"   \"chocolate cookies\"    \"dark chocolate fudge\"  \r\n\r\n\r\n\r\n\r\n\r\n#-----use cases for gsub()-----   \r\ndesserts <- c(\"chocolate\",\r\n              \"chocolate cake\",\r\n              \"chocolate tart\",\r\n              \"chocolate icecream\",\r\n              \"chocolate cookies\",\r\n              \"dark chocolate fudge\", \r\n              \"fruit\",\r\n              \"fruit tart\",\r\n              \"fruit sorbet\")\r\n\r\ngsub(\"(dark )?chocolate\", \"vanilla\", desserts) \r\n#> [1] \"vanilla\"          \"vanilla cake\"     \"vanilla tart\"     \"vanilla icecream\" \"vanilla cookies\"  \"vanilla fudge\"    \"fruit\"           \r\n#> [8] \"fruit tart\"       \"fruit sorbet\"    \r\n\r\nstr_replace_all(desserts, \"(dark )?chocolate\", \"vanilla\") \r\n#> [1] \"vanilla\"          \"vanilla cake\"     \"vanilla tart\"     \"vanilla icecream\" \"vanilla cookies\"  \"vanilla fudge\"    \"fruit\"           \r\n#> [8] \"fruit tart\"       \"fruit sorbet\"            \r\n\r\n\r\n\r\n\r\n\r\nbaser_vs_stringr <- microbenchmark(grep = grep(\".*\\\\bchocolate\\\\b.*\", desserts, value = F),\r\n                                   str_which = str_which(desserts, \".*\\\\bchocolate\\\\b.*\"),\r\n                                   gsub = gsub(\"chocolate\", \"vanilla\", desserts),\r\n                                   str_replace_all = str_replace_all(desserts, \"chocolate\", \"vanilla\"),\r\n                                   grepl = grepl(\".*\\\\bchocolate\\\\b.*\", desserts),\r\n                                   str_detect = str_detect(desserts, \".*\\\\bchocolate\\\\b.*\"),  \r\n                                   times = 1000)\r\n\r\nautoplot(baser_vs_stringr)  \r\n\r\n\r\n\r\n\r\nNote: Base R functions are significantly faster than their stringr equivalents.\r\nOther resources\r\nTips on regular expression usage are based on the excellent regular expressions vignette from stringr\r\nStrings chapter from R4DS by Garrett Grolemund and Hadley Wickham\r\nRStudio stringr cheatsheet\r\nhttps://regex101.com/ - a website for testing regular expressions\r\n\r\nMany R functions require R regex classes to be wrapped in a second set of [ ], e.g. [[:punct:]].↩\r\nAs a repetitive step within the workflow, we might want to rewrite the generic part of this cleaning step as a function stored in a separate R script for maximal readability.↩\r\n",
    "preview": "posts/2020-12-31-cleaning-free-text-and-wrangling-strings/benchmark.png",
    "last_modified": "2021-01-29T23:41:03+11:00",
    "input_file": {},
    "preview_width": 1949,
    "preview_height": 1200
  }
]
