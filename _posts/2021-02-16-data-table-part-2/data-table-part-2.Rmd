---
title: "Advanced data.table operations"  
description: |
  Things get querysome and querysome.         
author: Erika Duan
date: 02-16-2021
preview: finalplot.png 
categories: 
  - data cleaning  
  - data.table  
  - dplyr
  - R  
output:
  distill::distill_article: 
    toc: true
---

```{r setup, include=FALSE}
# Set up global environment ----------------------------------------------------  
knitr::opts_chunk$set(echo=TRUE, results='hide') 
options(scipen=999)
```


# Introduction    

This post is a continuation of [my previous comparison](https://erikaduan.github.io/posts/2021-01-30-data-table-part-1/) of R `data.table` versus `dplyr` functions.    

**Note:** The code used to create this dataset can be accessed from my github repository [here](https://github.com/erikaduan/R-tips/blob/master/03_blog_posts/2020-04-07_data-table-versus-dplyr/2020-04-07_data-table-versus-dplyr.md).    

```{r, message=FALSE, warning=FALSE}
# Load required packages -------------------------------------------------------  
if (!require("pacman")) install.packages("pacman")
pacman::p_load(here,
               ids, # Generate random IDs
               tidyverse,
               data.table,
               microbenchmark)
```

```{r, echo=FALSE}
# Create a function to generate random dates -----------------------------------
create_start_dates <- function(start_date, end_date, n) {
  # Assert requirement for character inputs 
  if(!is.character(start_date) | !is.character(end_date)) {
    stop("Error: start_date and end_date should be written in the format YYYY-mm-dd")
  }
  
  # Convert character inputs into dates
  start_date <- as.Date(start_date, format = "%Y-%m-%d")
  end_date <- as.Date(end_date, format = "%Y-%m-%d")  
  
  # Assert that end_date >= start_date  
  if(end_date < start_date) {
    stop("Error: start_date should be earlier than end_date")
  }
  
  # Generate date vector of random dates between start_date and end_date
  set.seed(111)
  sample(seq(start_date, end_date, by = "day"),
         n,
         replace = T)
}  
```

```{r, echo=FALSE}
# Create a function to populate course_end_dates -------------------------------
add_course_end_date <- function(df, include_n, row) {
  df %>% 
    group_by(join_key) %>% 
    mutate(course_end_date = if_else(n_courses >= include_n & row_number() == row,
                                     course_start_date + course_length,
                                     course_end_date)) %>%
    ungroup()
}
```

```{r, echo=FALSE}
# Create a function to populate course_start_dates -----------------------------
add_course_start_date <- function(df, include_n, row) {
  df %>% 
    group_by(join_key) %>% 
    mutate(course_start_date = if_else(n_courses >= include_n & row_number() == row,
                                       lag(course_end_date),
                                       course_start_date)) %>%
    ungroup()
}
```

```{r, echo=FALSE}
# Create 500000 student enrollments --------------------------------------------
# Create 150000 unique student IDs  
set.seed(111)
students <- random_id(n = 150000,
                      bytes = 4,
                      use_openssl = F) # So set.seed() works  

# Sample student IDs with replacement 500000 times 
id <- sample(students, 500000,
             replace = T) %>%
  sort()

# Simulate 5 platforms with different market shares  
platform <- sample(LETTERS[1:5], 500000,
                   replace = T,
                   prob = c(0.35, 0.05, 0.1, 0.3, 0.2)) 

# Create 20 courses 
all_courses <- c("R_beginner",
                 "R_intermediate",
                 "R_advanced",
                 "Python_beginner",
                 "Python_intermediate",
                 "Python_advanced",
                 "machine_learning",
                 "linear_algebra",
                 "statistics",
                 "UX_design",
                 "website_design",
                 "data_mining",
                 "travel_writing",
                 "bread_baking",
                 "pottery",
                 "poetry_writing",
                 "contemporary_dance",
                 "carpentry",
                 "metal_welding",
                 "fitness_training")  

course <- sample(all_courses, 500000,
                 replace = T)  

# Create student_courses ------------------------------------------------------- 
student_courses <- tibble(index = seq(1, 500000, 1), # index required for downstream joins
                          id,
                          platform,
                          course)
```

```{r, echo=FALSE}
# Create platform_start_date and platform_end_date entries----------------------
# Create join_key   
platform_subset <- student_courses %>%
  select(index, 
         id,
         platform) %>% 
  mutate(join_key = str_c(id, platform, sep = "-")) 

# Create lag_join_key  
platform_subset <- platform_subset %>%
  group_by(id) %>%
  mutate(lag_join_key = lag(join_key, 1)) %>%
  ungroup()  

# Filter rows representing the first course a student takes on a new platform      
platform_subset <- platform_subset %>%
  filter(is.na(lag_join_key) | lag_join_key != join_key)

# Create platform start_dates vector   
start_dates <- create_start_dates(start_date = "2016-01-01",
                                  end_date = "2019-01-01",  
                                  n = nrow(platform_subset))

platform_subset <- platform_subset %>%
  mutate(platform_start_date = start_dates)

# Create platform_end_date as platform_start_date + random platform_length 
set.seed(111)
platform_length <- runif(nrow(platform_subset),
                         min = 9, max = 90) %>%
  floor(.) 

# Round platform_length to a whole number i.e. whole day for date calculations   

platform_subset <- platform_subset %>%
  mutate(platform_end_date = platform_start_date + platform_length)  

# Left join student_course and provider_subset by index-------------------------
platform_subset <- platform_subset %>%
  select(index,
         platform_start_date,
         platform_end_date)     

student_courses <- left_join(student_courses,
                             platform_subset,
                             by = "index")

student_courses <- student_courses %>%
  fill(c(platform_start_date, platform_end_date), 
       .direction = "up") # NA inherits the value above    

student_courses <- student_courses %>%
  select(-index)   
```

```{r, echo=FALSE}
# Create course_start_date and course_end_date entries ------------------------- 
# Sort by id, platform start_date and platform   
student_courses <- student_courses %>%
  arrange(id, 
          platform_start_date,
          platform)

# Split student_courses into one_course and multiple_courses 
# Create join_key 
student_courses <- student_courses %>%
  mutate(platform_length = platform_end_date - platform_start_date,
         join_key = str_c(id, platform_start_date, platform, sep = "-"))

# Create lag_join_key 
student_courses <- student_courses %>%
  group_by(id) %>% 
  mutate(lag_join_key = lag(join_key)) %>%
  ungroup()

# Multiple courses exists when multiple rows share the same join_key     
multiple_courses_id <- student_courses %>%
  count(join_key) %>%
  filter(n > 1) %>%
  pull(join_key)

multiple_courses <- student_courses %>%
  filter(join_key %in% multiple_courses_id)

single_course <- student_courses %>%
  filter(!join_key %in% multiple_courses_id)

# Create course date logic for single_course------------------------------------  
single_course <- single_course %>%
  mutate(course_start_date = platform_start_date,
         course_end_date = platform_end_date) 

# Create course date logic for multiple_courses---------------------------------
# Check maximum number of courses undertaken on the same platform
multiple_courses %>%
  count(join_key) %>% 
  ungroup() %>%
  pull(n) %>%
  max()  
#> [1] 7

# Populate first course_start_date and last course_end_date for all cases    
set.seed(111)
multiple_courses <- multiple_courses %>%
  group_by(join_key) %>%
  mutate(n_courses = n(),
         course_start_date = if_else(row_number() == 1, platform_start_date,
                                     NA_real_),
         course_end_date = if_else(row_number() == n(), platform_end_date,
                                   NA_real_),
         course_length = runif(n = n(), min = 1, max = platform_length / n_courses) %>% ceiling()) %>%
  ungroup()

# Populate first course_end_date for all cases  
multiple_courses <- multiple_courses %>% 
  group_by(join_key) %>% 
  mutate(course_end_date = if_else(!is.na(course_start_date),
                                   course_start_date + course_length,
                                   course_end_date)) %>%
  ungroup()

# Populate second course_start_date when n_courses >= 2
multiple_courses <- add_course_start_date(multiple_courses, include_n = 2, row = 2)

# Populate second course_end_date when n_courses >= 3  
multiple_courses <- add_course_end_date(multiple_courses, include_n = 3, row = 2)

# Populate third course_start_date when n_courses >= 3  
multiple_courses <- add_course_start_date(multiple_courses, include_n = 3, row = 3)

# Populate third course_end_date when n_courses >= 4  
multiple_courses <- add_course_end_date(multiple_courses, include_n = 4, row = 3)

# Populate fourth course_start_date when n_courses >= 4  
multiple_courses <- add_course_start_date(multiple_courses, include_n = 4, row = 4)

# Populate fourth course_end_date when n_courses >= 5  
multiple_courses <- add_course_end_date(multiple_courses, include_n = 5, row = 4)

# Populate fifth course_start_date when n_courses >= 5  
multiple_courses <- add_course_start_date(multiple_courses, include_n = 5, row = 5)

# Populate fifth course_end_date when n_courses >= 6  
multiple_courses <- add_course_end_date(multiple_courses, include_n = 6, row = 5)

# Populate sixth course_start_date when n_courses >= 6  
multiple_courses <- add_course_start_date(multiple_courses, include_n = 6, row = 6)

# Populate sixth course_end_date when n_courses >= 7  
multiple_courses <- add_course_end_date(multiple_courses, include_n = 7, row = 6)

# Populate seventh course_start_date when n_courses >= 7  
multiple_courses <- add_course_start_date(multiple_courses, include_n = 7, row = 7)

# Bind all rows and re-order student_courses -----------------------------------    
student_courses <- bind_rows(single_course,
                             multiple_courses)

student_courses <- student_courses %>%
  select(-c(platform_length,
            course_length,
            n_courses,
            join_key,
            lag_join_key))  

student_courses <- student_courses %>%
  arrange(id,
          platform_start_date,
          platform)
```

```{r, echo=FALSE}
# Remove all objects except student_courses-------------------------------------  
rm(list = setdiff(ls(), "student_courses"))
gc()
```

We can interactively examine the first 20 rows of the dataset using the R package `DT`.      

```{r, echo=FALSE, results='markup'}
# Examine the first 12 rows of data--------------------------------------------  
student_courses %>%
  head(12) %>%
  datatable(rownames = F,
            options = list(pageLength = 6, dom = 'tip',
                           initComplete = JS(
                             "function(settings, json) {",
                             "$(this.api().table().header()).css({'background-color': '#37ACA1', 'color': '#fff'});",
                             "}")))
```
 
```{r} 
# Convert data frame to data.table ---------------------------------------------  
setDT(student_courses)

class(student_courses) 
#> [1] "data.table" "data.frame"  
```


# Code sequence outputs      


## Using `dplyr` versus `data.table`    

Imagine you would like to subset all fitness training courses from platform C and E and create a column to denote that these were discounted courses.   

In `dplyr`, you can write this as a single query using the `%>%` pipe to separate each individual function.        

```{r, results='markup'}
# Filter and create a new column using dplyr %>% pipes -------------------------    
dply_query_1 <- student_courses %>%
  filter(course == "fitness_training",
         platform %in% c("C", "E")) %>%
  mutate(percentage_discount = 5)

# Print the first 4 rows -------------------------------------------------------      
dply_query_1 %>% 
  select(-contains("_date")) %>% 
  head(4) %>%
  knitr::kable()  
```

In `data.table`, performing filtering and column transformations in separate steps or a single step produces different outputs. ^[Performing the two functions in separate steps is equivalent to the `dplyr` approach above.]    

```{r, results='markup'}
# Filter and create a new column using data.table in separate steps ------------  
dt_query_1 <- student_courses[(course == "fitness_training") 
                              & (platform %chin% c("C", "E"))] %>%
  .[, percentage_discount := 5]   

# Print the first 4 rows -------------------------------------------------------  
# Subset columns which contain "_date"
date_cols <- grep("_date$", colnames(student_courses), value = T)

dt_query_1[1:4, !..date_cols] %>%
  knitr::kable()
```

In `data.table, performing filtering and column transformations in a single step will retain all rows and apply a transformation to rows where the filtering condition is `TRUE`.    

```{r}
# Filter and create a new column using data.table in a single step -------------  
dt_query_1_wrong <- student_courses[(course == "fitness_training") 
                                    & (platform %chin% c("C", "E")), 
                                    percentage_discount := 5]

# Print the first 4 rows -------------------------------------------------------  
dt_query_1_wrong[1:4, !..date_cols] %>%
  knitr::kable()  
```


## Benchmark code sequences  

```{r}

```

```{r, echo=FALSE}
# Remove percentage_discount for downstream analyses ---------------------------  
student_courses[, percentage_discount := NULL]  
```


# Functions for summarising data    

A common operation is to group by and summarise across variable(s) to retrieve aggregate data. Very different outputs can be obtained by modifying `data.table` groupings in subtle ways.    


## Using `dplyr` versus `data.table`   

Imagine that we are interested in the total number of days each student has spent on any online platform. We might try to obtain this output by grouping on individual student IDs and calculating the total of days spent on any platform.     

```{r}
# Calculate total platform_length per student using dplyr ----------------------  
student_courses <- student_courses %>%
  mutate(platform_length = platform_end_date - platform_start_date,
         platform_length = as.integer(platform_length))  

dply_query_2 <- student_courses %>%
  group_by(id) %>%
  summarise(total_days = sum(platform_length),
            min_days = min(platform_length),
            median_days = median(platform_length),  
            max_days = max(platform_length)) %>%
  ungroup() 

# Print the first 4 rows -------------------------------------------------------
dply_query_2 %>%
  knitr::kable()  
```

**Note:** In `dplyr`, we need to close our sequence of code with the function `ungroup()`, which removes object metadata to denote row groupings.   

In `data.table`, we can choose which variable(s) to group by using either `by` or `keyby` in the `by` placeholder of `DT[i, j, by]`. The additional effect of using `keyby` is that `keyby` also orders the results and creates a secondary key for faster subsetting.       

```{r}
# Calculate total platform_length per student using data.table ----------------- 
dt_query_2 <- student_courses[,
                              .(total_days = sum(platform_length),
                                min_days = min(platform_length),
                                median_days = median(platform_length),
                                max_days = max(platform_length)),
                              keyby = id]

# Print the first 4 rows -------------------------------------------------------  
dt_query_2 %>%
  knitr::kable()
```

The problem with this approach is that some students switch between courses on the same platform so the platform dwell length can be duplicated if we simply group by students IDs. We can identify how often this occurs by concatenating `id`, `platform` and `platform_start_date` and removing duplicate rows.   

```{r}
# Identify duplicate rows using dplyr ------------------------------------------ 
student_courses <- student_courses %>%
  mutate(platform_key = str_c(online_platform, platform_start_date, sep = "-"))

#-----create platform_key using data.table-----  
student_courses[,
                platform_key := do.call(paste0, c(.SD, sep = "-")),
                .SDcols = c("online_platform", "platform_start_date")]
```

**Note:** The base R function `do.call()` constructs and executes a function call from a name or a function and a list of arguments to be passed to it.  

```{r}
#-----identify students with duplicate records in dplyr-----
dply_query_3 <- student_courses %>%
  group_by(student_id) %>%
  summarise(unique_platform_signups = n_distinct(platform_key),
            total_course_signups = n()) 

#-----return student_ids as vector and preview the first 3 elements-----
dply_query_3 %>%
  filter(total_course_signups > unique_platform_signups) %>%
  pull(student_id) %>%
  .[1:3]

#-----examine duplicate records example-----
student_courses %>%
  select(-c(platform_key)) %>%
  filter(student_id == "00040980")
```

```{r}
#-----identify students with duplicate records in data.table-----  
dt_query_3 <- student_courses[,
                              .(unique_platform_signups = length(unique(platform_key)),
                                total_course_signups = .N),
                              by = student_id] 

#-----return student_ids as vector and preview the first 3 elements-----
dt_query_3[total_course_signups > unique_platform_signups, 
           student_id] %>%
  .[1:3]

#-----examine duplicate records example-----  
student_courses[student_id == "00040980",
                !"platform_key"]  
```

 


## Group by and `lead` or `lag` operations   


# Other resources      

+ A great side-by-side comparison of `data.table` versus `dplyr` functions from a [blog post by Atrebas](https://atrebas.github.io/post/2019-03-03-datatable-dplyr/).             

+ A list of advanced `data.table` operations and tricks from a [blog post by Andrew Brooks](http://brooksandrew.github.io/simpleblog/articles/advanced-data-table/).    